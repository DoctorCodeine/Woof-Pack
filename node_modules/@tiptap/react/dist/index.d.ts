import { BubbleMenuPluginProps } from '@tiptap/extension-bubble-menu';
import React, { HTMLProps, DependencyList } from 'react';
import { Editor as Editor$1, NodeViewRendererOptions, NodeViewRenderer, EditorOptions } from '@tiptap/core';
export * from '@tiptap/core';
import { FloatingMenuPluginProps } from '@tiptap/extension-floating-menu';
import { Node } from '@tiptap/pm/model';
import { Decoration } from '@tiptap/pm/view';

declare type Optional$1<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>;
declare type BubbleMenuProps = Omit<Optional$1<BubbleMenuPluginProps, 'pluginKey'>, 'element'> & {
    className?: string;
    children: React.ReactNode;
    updateDelay?: number;
};
declare const BubbleMenu: (props: BubbleMenuProps) => JSX.Element;

interface ReactRendererOptions {
    editor: Editor$1;
    props?: Record<string, any>;
    as?: string;
    className?: string;
}
declare type ComponentType<R, P> = React.ComponentClass<P> | React.FunctionComponent<P> | React.ForwardRefExoticComponent<React.PropsWithoutRef<P> & React.RefAttributes<R>>;
declare class ReactRenderer<R = unknown, P = unknown> {
    id: string;
    editor: Editor;
    component: any;
    element: Element;
    props: Record<string, any>;
    reactElement: React.ReactNode;
    ref: R | null;
    constructor(component: ComponentType<R, P>, { editor, props, as, className, }: ReactRendererOptions);
    render(): void;
    updateProps(props?: Record<string, any>): void;
    destroy(): void;
}

interface EditorContentProps extends HTMLProps<HTMLDivElement> {
    editor: Editor | null;
}
interface EditorContentState {
    renderers: Record<string, ReactRenderer>;
}
declare class PureEditorContent extends React.Component<EditorContentProps, EditorContentState> {
    editorContentRef: React.RefObject<any>;
    initialized: boolean;
    constructor(props: EditorContentProps);
    componentDidMount(): void;
    componentDidUpdate(): void;
    init(): void;
    maybeFlushSync(fn: () => void): void;
    setRenderer(id: string, renderer: ReactRenderer): void;
    removeRenderer(id: string): void;
    componentWillUnmount(): void;
    render(): JSX.Element;
}
declare const EditorContent: React.MemoExoticComponent<typeof PureEditorContent>;

declare type ContentComponent = React.Component<EditorContentProps, EditorContentState> & {
    setRenderer(id: string, renderer: ReactRenderer): void;
    removeRenderer(id: string): void;
};
declare class Editor extends Editor$1 {
    contentComponent: ContentComponent | null;
}

declare type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>;
declare type FloatingMenuProps = Omit<Optional<FloatingMenuPluginProps, 'pluginKey'>, 'element'> & {
    className?: string;
    children: React.ReactNode;
};
declare const FloatingMenu: (props: FloatingMenuProps) => JSX.Element;

interface NodeViewContentProps {
    [key: string]: any;
    as?: React.ElementType;
}
declare const NodeViewContent: React.FC<NodeViewContentProps>;

interface NodeViewWrapperProps {
    [key: string]: any;
    as?: React.ElementType;
}
declare const NodeViewWrapper: React.FC<NodeViewWrapperProps>;

interface ReactNodeViewRendererOptions extends NodeViewRendererOptions {
    update: ((props: {
        oldNode: Node;
        oldDecorations: Decoration[];
        newNode: Node;
        newDecorations: Decoration[];
        updateProps: () => void;
    }) => boolean) | null;
    as?: string;
    className?: string;
}
declare function ReactNodeViewRenderer(component: any, options?: Partial<ReactNodeViewRendererOptions>): NodeViewRenderer;

declare const useEditor: (options?: Partial<EditorOptions>, deps?: DependencyList) => Editor | null;

export { BubbleMenu, BubbleMenuProps, Editor, EditorContent, EditorContentProps, EditorContentState, FloatingMenu, FloatingMenuProps, NodeViewContent, NodeViewContentProps, NodeViewWrapper, NodeViewWrapperProps, PureEditorContent, ReactNodeViewRenderer, ReactNodeViewRendererOptions, ReactRenderer, ReactRendererOptions, useEditor };
