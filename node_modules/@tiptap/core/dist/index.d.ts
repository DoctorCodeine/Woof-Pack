import { EditorState, Plugin, Transaction, PluginKey, Selection, NodeSelection, TextSelection } from '@tiptap/pm/state';
import { NodeType, NodeSpec, Node as Node$1, DOMOutputSpec, MarkType, MarkSpec, Mark as Mark$1, ParseOptions, Schema, ContentMatch, ResolvedPos, Fragment } from '@tiptap/pm/model';
import { NodeView as NodeView$1, EditorProps, EditorView, Decoration } from '@tiptap/pm/view';
import { Transform } from '@tiptap/pm/transform';
import * as prosemirror_model from 'prosemirror-model';

declare type StringKeyOf<T> = Extract<keyof T, string>;
declare type CallbackType<T extends Record<string, any>, EventName extends StringKeyOf<T>> = T[EventName] extends any[] ? T[EventName] : [T[EventName]];
declare type CallbackFunction<T extends Record<string, any>, EventName extends StringKeyOf<T>> = (...props: CallbackType<T, EventName>) => any;
declare class EventEmitter<T extends Record<string, any>> {
    private callbacks;
    on<EventName extends StringKeyOf<T>>(event: EventName, fn: CallbackFunction<T, EventName>): this;
    protected emit<EventName extends StringKeyOf<T>>(event: EventName, ...args: CallbackType<T, EventName>): this;
    off<EventName extends StringKeyOf<T>>(event: EventName, fn?: CallbackFunction<T, EventName>): this;
    protected removeAllListeners(): void;
}

declare type InputRuleMatch = {
    index: number;
    text: string;
    replaceWith?: string;
    match?: RegExpMatchArray;
    data?: Record<string, any>;
};
declare type InputRuleFinder = RegExp | ((text: string) => InputRuleMatch | null);
declare class InputRule {
    find: InputRuleFinder;
    handler: (props: {
        state: EditorState;
        range: Range;
        match: ExtendedRegExpMatchArray;
        commands: SingleCommands;
        chain: () => ChainedCommands;
        can: () => CanCommands;
    }) => void | null;
    constructor(config: {
        find: InputRuleFinder;
        handler: (props: {
            state: EditorState;
            range: Range;
            match: ExtendedRegExpMatchArray;
            commands: SingleCommands;
            chain: () => ChainedCommands;
            can: () => CanCommands;
        }) => void | null;
    });
}
/**
 * Create an input rules plugin. When enabled, it will cause text
 * input that matches any of the given rules to trigger the rule’s
 * action.
 */
declare function inputRulesPlugin(props: {
    editor: Editor;
    rules: InputRule[];
}): Plugin;

declare type PasteRuleMatch = {
    index: number;
    text: string;
    replaceWith?: string;
    match?: RegExpMatchArray;
    data?: Record<string, any>;
};
declare type PasteRuleFinder = RegExp | ((text: string) => PasteRuleMatch[] | null | undefined);
declare class PasteRule {
    find: PasteRuleFinder;
    handler: (props: {
        state: EditorState;
        range: Range;
        match: ExtendedRegExpMatchArray;
        commands: SingleCommands;
        chain: () => ChainedCommands;
        can: () => CanCommands;
    }) => void | null;
    constructor(config: {
        find: PasteRuleFinder;
        handler: (props: {
            state: EditorState;
            range: Range;
            match: ExtendedRegExpMatchArray;
            commands: SingleCommands;
            chain: () => ChainedCommands;
            can: () => CanCommands;
        }) => void | null;
    });
}
/**
 * Create an paste rules plugin. When enabled, it will cause pasted
 * text that matches any of the given rules to trigger the rule’s
 * action.
 */
declare function pasteRulesPlugin(props: {
    editor: Editor;
    rules: PasteRule[];
}): Plugin[];

declare module '@tiptap/core' {
    interface NodeConfig<Options = any, Storage = any> {
        [key: string]: any;
        /**
         * Name
         */
        name: string;
        /**
         * Priority
         */
        priority?: number;
        /**
         * Default options
         */
        defaultOptions?: Options;
        /**
         * Default Options
         */
        addOptions?: (this: {
            name: string;
            parent: Exclude<ParentConfig<NodeConfig<Options, Storage>>['addOptions'], undefined>;
        }) => Options;
        /**
         * Default Storage
         */
        addStorage?: (this: {
            name: string;
            options: Options;
            parent: Exclude<ParentConfig<NodeConfig<Options, Storage>>['addStorage'], undefined>;
        }) => Storage;
        /**
         * Global attributes
         */
        addGlobalAttributes?: (this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<NodeConfig<Options, Storage>>['addGlobalAttributes'];
        }) => GlobalAttributes | {};
        /**
         * Raw
         */
        addCommands?: (this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            type: NodeType;
            parent: ParentConfig<NodeConfig<Options, Storage>>['addCommands'];
        }) => Partial<RawCommands>;
        /**
         * Keyboard shortcuts
         */
        addKeyboardShortcuts?: (this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            type: NodeType;
            parent: ParentConfig<NodeConfig<Options, Storage>>['addKeyboardShortcuts'];
        }) => {
            [key: string]: KeyboardShortcutCommand;
        };
        /**
         * Input rules
         */
        addInputRules?: (this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            type: NodeType;
            parent: ParentConfig<NodeConfig<Options, Storage>>['addInputRules'];
        }) => InputRule[];
        /**
         * Paste rules
         */
        addPasteRules?: (this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            type: NodeType;
            parent: ParentConfig<NodeConfig<Options, Storage>>['addPasteRules'];
        }) => PasteRule[];
        /**
         * ProseMirror plugins
         */
        addProseMirrorPlugins?: (this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            type: NodeType;
            parent: ParentConfig<NodeConfig<Options, Storage>>['addProseMirrorPlugins'];
        }) => Plugin[];
        /**
         * Extensions
         */
        addExtensions?: (this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<NodeConfig<Options, Storage>>['addExtensions'];
        }) => Extensions;
        /**
         * Extend Node Schema
         */
        extendNodeSchema?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<NodeConfig<Options, Storage>>['extendNodeSchema'];
        }, extension: Node) => Record<string, any>) | null;
        /**
         * Extend Mark Schema
         */
        extendMarkSchema?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<NodeConfig<Options, Storage>>['extendMarkSchema'];
        }, extension: Node) => Record<string, any>) | null;
        /**
         * The editor is not ready yet.
         */
        onBeforeCreate?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            type: NodeType;
            parent: ParentConfig<NodeConfig<Options, Storage>>['onBeforeCreate'];
        }) => void) | null;
        /**
         * The editor is ready.
         */
        onCreate?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            type: NodeType;
            parent: ParentConfig<NodeConfig<Options, Storage>>['onCreate'];
        }) => void) | null;
        /**
         * The content has changed.
         */
        onUpdate?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            type: NodeType;
            parent: ParentConfig<NodeConfig<Options, Storage>>['onUpdate'];
        }) => void) | null;
        /**
         * The selection has changed.
         */
        onSelectionUpdate?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            type: NodeType;
            parent: ParentConfig<NodeConfig<Options, Storage>>['onSelectionUpdate'];
        }) => void) | null;
        /**
         * The editor state has changed.
         */
        onTransaction?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            type: NodeType;
            parent: ParentConfig<NodeConfig<Options, Storage>>['onTransaction'];
        }, props: {
            transaction: Transaction;
        }) => void) | null;
        /**
         * The editor is focused.
         */
        onFocus?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            type: NodeType;
            parent: ParentConfig<NodeConfig<Options, Storage>>['onFocus'];
        }, props: {
            event: FocusEvent;
        }) => void) | null;
        /**
         * The editor isn’t focused anymore.
         */
        onBlur?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            type: NodeType;
            parent: ParentConfig<NodeConfig<Options, Storage>>['onBlur'];
        }, props: {
            event: FocusEvent;
        }) => void) | null;
        /**
         * The editor is destroyed.
         */
        onDestroy?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            type: NodeType;
            parent: ParentConfig<NodeConfig<Options, Storage>>['onDestroy'];
        }) => void) | null;
        /**
         * Node View
         */
        addNodeView?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            type: NodeType;
            parent: ParentConfig<NodeConfig<Options, Storage>>['addNodeView'];
        }) => NodeViewRenderer) | null;
        /**
         * TopNode
         */
        topNode?: boolean;
        /**
         * Content
         */
        content?: NodeSpec['content'] | ((this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<NodeConfig<Options, Storage>>['content'];
        }) => NodeSpec['content']);
        /**
         * Marks
         */
        marks?: NodeSpec['marks'] | ((this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<NodeConfig<Options, Storage>>['marks'];
        }) => NodeSpec['marks']);
        /**
         * Group
         */
        group?: NodeSpec['group'] | ((this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<NodeConfig<Options, Storage>>['group'];
        }) => NodeSpec['group']);
        /**
         * Inline
         */
        inline?: NodeSpec['inline'] | ((this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<NodeConfig<Options, Storage>>['inline'];
        }) => NodeSpec['inline']);
        /**
         * Atom
         */
        atom?: NodeSpec['atom'] | ((this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<NodeConfig<Options, Storage>>['atom'];
        }) => NodeSpec['atom']);
        /**
         * Selectable
         */
        selectable?: NodeSpec['selectable'] | ((this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<NodeConfig<Options, Storage>>['selectable'];
        }) => NodeSpec['selectable']);
        /**
         * Draggable
         */
        draggable?: NodeSpec['draggable'] | ((this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<NodeConfig<Options, Storage>>['draggable'];
        }) => NodeSpec['draggable']);
        /**
         * Code
         */
        code?: NodeSpec['code'] | ((this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<NodeConfig<Options, Storage>>['code'];
        }) => NodeSpec['code']);
        /**
         * Whitespace
         */
        whitespace?: NodeSpec['whitespace'] | ((this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<NodeConfig<Options, Storage>>['whitespace'];
        }) => NodeSpec['whitespace']);
        /**
         * Defining
         */
        defining?: NodeSpec['defining'] | ((this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<NodeConfig<Options, Storage>>['defining'];
        }) => NodeSpec['defining']);
        /**
         * Isolating
         */
        isolating?: NodeSpec['isolating'] | ((this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<NodeConfig<Options, Storage>>['isolating'];
        }) => NodeSpec['isolating']);
        /**
         * Parse HTML
         */
        parseHTML?: (this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<NodeConfig<Options, Storage>>['parseHTML'];
        }) => NodeSpec['parseDOM'];
        /**
         * Render HTML
         */
        renderHTML?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<NodeConfig<Options, Storage>>['renderHTML'];
        }, props: {
            node: Node$1;
            HTMLAttributes: Record<string, any>;
        }) => DOMOutputSpec) | null;
        /**
         * Render Text
         */
        renderText?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<NodeConfig<Options, Storage>>['renderText'];
        }, props: {
            node: Node$1;
            pos: number;
            parent: Node$1;
            index: number;
        }) => string) | null;
        /**
         * Add Attributes
         */
        addAttributes?: (this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<NodeConfig<Options, Storage>>['addAttributes'];
        }) => Attributes | {};
    }
}
declare class Node<Options = any, Storage = any> {
    type: string;
    name: string;
    parent: Node | null;
    child: Node | null;
    options: Options;
    storage: Storage;
    config: NodeConfig;
    constructor(config?: Partial<NodeConfig<Options, Storage>>);
    static create<O = any, S = any>(config?: Partial<NodeConfig<O, S>>): Node<O, S>;
    configure(options?: Partial<Options>): Node<Options, Storage>;
    extend<ExtendedOptions = Options, ExtendedStorage = Storage>(extendedConfig?: Partial<NodeConfig<ExtendedOptions, ExtendedStorage>>): Node<ExtendedOptions, ExtendedStorage>;
}

declare module '@tiptap/core' {
    interface MarkConfig<Options = any, Storage = any> {
        [key: string]: any;
        /**
         * Name
         */
        name: string;
        /**
         * Priority
         */
        priority?: number;
        /**
         * Default options
         */
        defaultOptions?: Options;
        /**
         * Default Options
         */
        addOptions?: (this: {
            name: string;
            parent: Exclude<ParentConfig<MarkConfig<Options, Storage>>['addOptions'], undefined>;
        }) => Options;
        /**
         * Default Storage
         */
        addStorage?: (this: {
            name: string;
            options: Options;
            parent: Exclude<ParentConfig<MarkConfig<Options, Storage>>['addStorage'], undefined>;
        }) => Storage;
        /**
         * Global attributes
         */
        addGlobalAttributes?: (this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<MarkConfig<Options, Storage>>['addGlobalAttributes'];
        }) => GlobalAttributes | {};
        /**
         * Raw
         */
        addCommands?: (this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            type: MarkType;
            parent: ParentConfig<MarkConfig<Options, Storage>>['addCommands'];
        }) => Partial<RawCommands>;
        /**
         * Keyboard shortcuts
         */
        addKeyboardShortcuts?: (this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            type: MarkType;
            parent: ParentConfig<MarkConfig<Options, Storage>>['addKeyboardShortcuts'];
        }) => {
            [key: string]: KeyboardShortcutCommand;
        };
        /**
         * Input rules
         */
        addInputRules?: (this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            type: MarkType;
            parent: ParentConfig<MarkConfig<Options, Storage>>['addInputRules'];
        }) => InputRule[];
        /**
         * Paste rules
         */
        addPasteRules?: (this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            type: MarkType;
            parent: ParentConfig<MarkConfig<Options, Storage>>['addPasteRules'];
        }) => PasteRule[];
        /**
         * ProseMirror plugins
         */
        addProseMirrorPlugins?: (this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            type: MarkType;
            parent: ParentConfig<MarkConfig<Options, Storage>>['addProseMirrorPlugins'];
        }) => Plugin[];
        /**
         * Extensions
         */
        addExtensions?: (this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<MarkConfig<Options, Storage>>['addExtensions'];
        }) => Extensions;
        /**
         * Extend Node Schema
         */
        extendNodeSchema?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<MarkConfig<Options, Storage>>['extendNodeSchema'];
        }, extension: Node) => Record<string, any>) | null;
        /**
         * Extend Mark Schema
         */
        extendMarkSchema?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<MarkConfig<Options, Storage>>['extendMarkSchema'];
        }, extension: Mark) => Record<string, any>) | null;
        /**
         * The editor is not ready yet.
         */
        onBeforeCreate?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            type: MarkType;
            parent: ParentConfig<MarkConfig<Options, Storage>>['onBeforeCreate'];
        }) => void) | null;
        /**
         * The editor is ready.
         */
        onCreate?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            type: MarkType;
            parent: ParentConfig<MarkConfig<Options, Storage>>['onCreate'];
        }) => void) | null;
        /**
         * The content has changed.
         */
        onUpdate?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            type: MarkType;
            parent: ParentConfig<MarkConfig<Options, Storage>>['onUpdate'];
        }) => void) | null;
        /**
         * The selection has changed.
         */
        onSelectionUpdate?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            type: MarkType;
            parent: ParentConfig<MarkConfig<Options, Storage>>['onSelectionUpdate'];
        }) => void) | null;
        /**
         * The editor state has changed.
         */
        onTransaction?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            type: MarkType;
            parent: ParentConfig<MarkConfig<Options, Storage>>['onTransaction'];
        }, props: {
            transaction: Transaction;
        }) => void) | null;
        /**
         * The editor is focused.
         */
        onFocus?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            type: MarkType;
            parent: ParentConfig<MarkConfig<Options, Storage>>['onFocus'];
        }, props: {
            event: FocusEvent;
        }) => void) | null;
        /**
         * The editor isn’t focused anymore.
         */
        onBlur?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            type: MarkType;
            parent: ParentConfig<MarkConfig<Options, Storage>>['onBlur'];
        }, props: {
            event: FocusEvent;
        }) => void) | null;
        /**
         * The editor is destroyed.
         */
        onDestroy?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            type: MarkType;
            parent: ParentConfig<MarkConfig<Options, Storage>>['onDestroy'];
        }) => void) | null;
        /**
         * Keep mark after split node
         */
        keepOnSplit?: boolean | (() => boolean);
        /**
         * Inclusive
         */
        inclusive?: MarkSpec['inclusive'] | ((this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<MarkConfig<Options, Storage>>['inclusive'];
        }) => MarkSpec['inclusive']);
        /**
         * Excludes
         */
        excludes?: MarkSpec['excludes'] | ((this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<MarkConfig<Options, Storage>>['excludes'];
        }) => MarkSpec['excludes']);
        /**
         * Marks this Mark as exitable
         */
        exitable?: boolean | (() => boolean);
        /**
         * Group
         */
        group?: MarkSpec['group'] | ((this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<MarkConfig<Options, Storage>>['group'];
        }) => MarkSpec['group']);
        /**
         * Spanning
         */
        spanning?: MarkSpec['spanning'] | ((this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<MarkConfig<Options, Storage>>['spanning'];
        }) => MarkSpec['spanning']);
        /**
         * Code
         */
        code?: boolean | ((this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<MarkConfig<Options, Storage>>['code'];
        }) => boolean);
        /**
         * Parse HTML
         */
        parseHTML?: (this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<MarkConfig<Options, Storage>>['parseHTML'];
        }) => MarkSpec['parseDOM'];
        /**
         * Render HTML
         */
        renderHTML?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<MarkConfig<Options, Storage>>['renderHTML'];
        }, props: {
            mark: Mark$1;
            HTMLAttributes: Record<string, any>;
        }) => DOMOutputSpec) | null;
        /**
         * Attributes
         */
        addAttributes?: (this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<MarkConfig<Options, Storage>>['addAttributes'];
        }) => Attributes | {};
    }
}
declare class Mark<Options = any, Storage = any> {
    type: string;
    name: string;
    parent: Mark | null;
    child: Mark | null;
    options: Options;
    storage: Storage;
    config: MarkConfig;
    constructor(config?: Partial<MarkConfig<Options, Storage>>);
    static create<O = any, S = any>(config?: Partial<MarkConfig<O, S>>): Mark<O, S>;
    configure(options?: Partial<Options>): Mark<Options, Storage>;
    extend<ExtendedOptions = Options, ExtendedStorage = Storage>(extendedConfig?: Partial<MarkConfig<ExtendedOptions, ExtendedStorage>>): Mark<ExtendedOptions, ExtendedStorage>;
    static handleExit({ editor, mark }: {
        editor: Editor;
        mark: Mark;
    }): boolean;
}

declare module '@tiptap/core' {
    interface ExtensionConfig<Options = any, Storage = any> {
        [key: string]: any;
        /**
         * Name
         */
        name: string;
        /**
         * Priority
         */
        priority?: number;
        /**
         * Default options
         */
        defaultOptions?: Options;
        /**
         * Default Options
         */
        addOptions?: (this: {
            name: string;
            parent: Exclude<ParentConfig<ExtensionConfig<Options, Storage>>['addOptions'], undefined>;
        }) => Options;
        /**
         * Default Storage
         */
        addStorage?: (this: {
            name: string;
            options: Options;
            parent: Exclude<ParentConfig<ExtensionConfig<Options, Storage>>['addStorage'], undefined>;
        }) => Storage;
        /**
         * Global attributes
         */
        addGlobalAttributes?: (this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<ExtensionConfig<Options, Storage>>['addGlobalAttributes'];
        }) => GlobalAttributes | {};
        /**
         * Raw
         */
        addCommands?: (this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            parent: ParentConfig<ExtensionConfig<Options, Storage>>['addCommands'];
        }) => Partial<RawCommands>;
        /**
         * Keyboard shortcuts
         */
        addKeyboardShortcuts?: (this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            parent: ParentConfig<ExtensionConfig<Options, Storage>>['addKeyboardShortcuts'];
        }) => {
            [key: string]: KeyboardShortcutCommand;
        };
        /**
         * Input rules
         */
        addInputRules?: (this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            parent: ParentConfig<ExtensionConfig<Options, Storage>>['addInputRules'];
        }) => InputRule[];
        /**
         * Paste rules
         */
        addPasteRules?: (this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            parent: ParentConfig<ExtensionConfig<Options, Storage>>['addPasteRules'];
        }) => PasteRule[];
        /**
         * ProseMirror plugins
         */
        addProseMirrorPlugins?: (this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            parent: ParentConfig<ExtensionConfig<Options, Storage>>['addProseMirrorPlugins'];
        }) => Plugin[];
        /**
         * Extensions
         */
        addExtensions?: (this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<ExtensionConfig<Options, Storage>>['addExtensions'];
        }) => Extensions;
        /**
         * Extend Node Schema
         */
        extendNodeSchema?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<ExtensionConfig<Options, Storage>>['extendNodeSchema'];
        }, extension: Node) => Record<string, any>) | null;
        /**
         * Extend Mark Schema
         */
        extendMarkSchema?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            parent: ParentConfig<ExtensionConfig<Options, Storage>>['extendMarkSchema'];
        }, extension: Mark) => Record<string, any>) | null;
        /**
         * The editor is not ready yet.
         */
        onBeforeCreate?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            parent: ParentConfig<ExtensionConfig<Options, Storage>>['onBeforeCreate'];
        }) => void) | null;
        /**
         * The editor is ready.
         */
        onCreate?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            parent: ParentConfig<ExtensionConfig<Options, Storage>>['onCreate'];
        }) => void) | null;
        /**
         * The content has changed.
         */
        onUpdate?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            parent: ParentConfig<ExtensionConfig<Options, Storage>>['onUpdate'];
        }) => void) | null;
        /**
         * The selection has changed.
         */
        onSelectionUpdate?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            parent: ParentConfig<ExtensionConfig<Options, Storage>>['onSelectionUpdate'];
        }) => void) | null;
        /**
         * The editor state has changed.
         */
        onTransaction?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            parent: ParentConfig<ExtensionConfig<Options, Storage>>['onTransaction'];
        }, props: {
            transaction: Transaction;
        }) => void) | null;
        /**
         * The editor is focused.
         */
        onFocus?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            parent: ParentConfig<ExtensionConfig<Options, Storage>>['onFocus'];
        }, props: {
            event: FocusEvent;
        }) => void) | null;
        /**
         * The editor isn’t focused anymore.
         */
        onBlur?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            parent: ParentConfig<ExtensionConfig<Options, Storage>>['onBlur'];
        }, props: {
            event: FocusEvent;
        }) => void) | null;
        /**
         * The editor is destroyed.
         */
        onDestroy?: ((this: {
            name: string;
            options: Options;
            storage: Storage;
            editor: Editor;
            parent: ParentConfig<ExtensionConfig<Options, Storage>>['onDestroy'];
        }) => void) | null;
    }
}
declare class Extension<Options = any, Storage = any> {
    type: string;
    name: string;
    parent: Extension | null;
    child: Extension | null;
    options: Options;
    storage: Storage;
    config: ExtensionConfig;
    constructor(config?: Partial<ExtensionConfig<Options, Storage>>);
    static create<O = any, S = any>(config?: Partial<ExtensionConfig<O, S>>): Extension<O, S>;
    configure(options?: Partial<Options>): Extension<Options, Storage>;
    extend<ExtendedOptions = Options, ExtendedStorage = Storage>(extendedConfig?: Partial<ExtensionConfig<ExtendedOptions, ExtendedStorage>>): Extension<ExtendedOptions, ExtendedStorage>;
}

declare type AnyConfig = ExtensionConfig | NodeConfig | MarkConfig;
declare type AnyExtension = Extension | Node | Mark;
declare type Extensions = AnyExtension[];
declare type ParentConfig<T> = Partial<{
    [P in keyof T]: Required<T>[P] extends (...args: any) => any ? (...args: Parameters<Required<T>[P]>) => ReturnType<Required<T>[P]> : T[P];
}>;
declare type Primitive = null | undefined | string | number | boolean | symbol | bigint;
declare type RemoveThis<T> = T extends (...args: any) => any ? (...args: Parameters<T>) => ReturnType<T> : T;
declare type MaybeReturnType<T> = T extends (...args: any) => any ? ReturnType<T> : T;
declare type MaybeThisParameterType<T> = Exclude<T, Primitive> extends (...args: any) => any ? ThisParameterType<Exclude<T, Primitive>> : any;
interface EditorEvents {
    beforeCreate: {
        editor: Editor;
    };
    create: {
        editor: Editor;
    };
    update: {
        editor: Editor;
        transaction: Transaction;
    };
    selectionUpdate: {
        editor: Editor;
        transaction: Transaction;
    };
    transaction: {
        editor: Editor;
        transaction: Transaction;
    };
    focus: {
        editor: Editor;
        event: FocusEvent;
        transaction: Transaction;
    };
    blur: {
        editor: Editor;
        event: FocusEvent;
        transaction: Transaction;
    };
    destroy: void;
}
declare type EnableRules = (AnyExtension | string)[] | boolean;
interface EditorOptions {
    element: Element;
    content: Content;
    extensions: Extensions;
    injectCSS: boolean;
    injectNonce: string | undefined;
    autofocus: FocusPosition;
    editable: boolean;
    editorProps: EditorProps;
    parseOptions: ParseOptions;
    enableInputRules: EnableRules;
    enablePasteRules: EnableRules;
    enableCoreExtensions: boolean;
    onBeforeCreate: (props: EditorEvents['beforeCreate']) => void;
    onCreate: (props: EditorEvents['create']) => void;
    onUpdate: (props: EditorEvents['update']) => void;
    onSelectionUpdate: (props: EditorEvents['selectionUpdate']) => void;
    onTransaction: (props: EditorEvents['transaction']) => void;
    onFocus: (props: EditorEvents['focus']) => void;
    onBlur: (props: EditorEvents['blur']) => void;
    onDestroy: (props: EditorEvents['destroy']) => void;
}
declare type HTMLContent = string;
declare type JSONContent = {
    type?: string;
    attrs?: Record<string, any>;
    content?: JSONContent[];
    marks?: {
        type: string;
        attrs?: Record<string, any>;
        [key: string]: any;
    }[];
    text?: string;
    [key: string]: any;
};
declare type Content = HTMLContent | JSONContent | JSONContent[] | null;
declare type CommandProps = {
    editor: Editor;
    tr: Transaction;
    commands: SingleCommands;
    can: () => CanCommands;
    chain: () => ChainedCommands;
    state: EditorState;
    view: EditorView;
    dispatch: ((args?: any) => any) | undefined;
};
declare type Command = (props: CommandProps) => boolean;
declare type CommandSpec = (...args: any[]) => Command;
declare type KeyboardShortcutCommand = (props: {
    editor: Editor;
}) => boolean;
declare type Attribute = {
    default: any;
    rendered?: boolean;
    renderHTML?: ((attributes: Record<string, any>) => Record<string, any> | null) | null;
    parseHTML?: ((element: HTMLElement) => any | null) | null;
    keepOnSplit: boolean;
    isRequired?: boolean;
};
declare type Attributes = {
    [key: string]: Attribute;
};
declare type ExtensionAttribute = {
    type: string;
    name: string;
    attribute: Required<Attribute>;
};
declare type GlobalAttributes = {
    types: string[];
    attributes: {
        [key: string]: Attribute;
    };
}[];
declare type PickValue<T, K extends keyof T> = T[K];
declare type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
declare type Diff<T extends keyof any, U extends keyof any> = ({
    [P in T]: P;
} & {
    [P in U]: never;
} & {
    [x: string]: never;
})[T];
declare type Overwrite<T, U> = Pick<T, Diff<keyof T, keyof U>> & U;
declare type ValuesOf<T> = T[keyof T];
declare type KeysWithTypeOf<T, Type> = {
    [P in keyof T]: T[P] extends Type ? P : never;
}[keyof T];
declare type NodeViewProps = {
    editor: Editor;
    node: Node$1;
    decorations: Decoration[];
    selected: boolean;
    extension: Node;
    getPos: () => number;
    updateAttributes: (attributes: Record<string, any>) => void;
    deleteNode: () => void;
};
interface NodeViewRendererOptions {
    stopEvent: ((props: {
        event: Event;
    }) => boolean) | null;
    ignoreMutation: ((props: {
        mutation: MutationRecord | {
            type: 'selection';
            target: Element;
        };
    }) => boolean) | null;
}
declare type NodeViewRendererProps = {
    editor: Editor;
    node: Node$1;
    getPos: (() => number) | boolean;
    HTMLAttributes: Record<string, any>;
    decorations: Decoration[];
    extension: Node;
};
declare type NodeViewRenderer = (props: NodeViewRendererProps) => NodeView$1 | {};
declare type AnyCommands = Record<string, (...args: any[]) => Command>;
declare type UnionCommands<T = Command> = UnionToIntersection<ValuesOf<Pick<Commands<T>, KeysWithTypeOf<Commands<T>, {}>>>>;
declare type RawCommands = {
    [Item in keyof UnionCommands]: UnionCommands<Command>[Item];
};
declare type SingleCommands = {
    [Item in keyof UnionCommands]: UnionCommands<boolean>[Item];
};
declare type ChainedCommands = {
    [Item in keyof UnionCommands]: UnionCommands<ChainedCommands>[Item];
} & {
    run: () => boolean;
};
declare type CanCommands = SingleCommands & {
    chain: () => ChainedCommands;
};
declare type FocusPosition = 'start' | 'end' | 'all' | number | boolean | null;
declare type Range = {
    from: number;
    to: number;
};
declare type NodeRange = {
    node: Node$1;
    from: number;
    to: number;
};
declare type MarkRange = {
    mark: Mark$1;
    from: number;
    to: number;
};
declare type Predicate = (node: Node$1) => boolean;
declare type NodeWithPos = {
    node: Node$1;
    pos: number;
};
declare type TextSerializer = (props: {
    node: Node$1;
    pos: number;
    parent: Node$1;
    index: number;
    range: Range;
}) => string;
declare type ExtendedRegExpMatchArray = RegExpMatchArray & {
    data?: Record<string, any>;
};
declare type Dispatch = ((args?: any) => any) | undefined;

declare class ExtensionManager {
    editor: Editor;
    schema: Schema;
    extensions: Extensions;
    splittableMarks: string[];
    constructor(extensions: Extensions, editor: Editor);
    static resolve(extensions: Extensions): Extensions;
    static flatten(extensions: Extensions): Extensions;
    static sort(extensions: Extensions): Extensions;
    get commands(): RawCommands;
    get plugins(): Plugin[];
    get attributes(): ExtensionAttribute[];
    get nodeViews(): any;
}

declare const ClipboardTextSerializer: Extension<any, any>;

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        blur: {
            /**
             * Removes focus from the editor.
             */
            blur: () => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        clearContent: {
            /**
             * Clear the whole document.
             */
            clearContent: (emitUpdate?: boolean) => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        clearNodes: {
            /**
             * Normalize nodes to a simple paragraph.
             */
            clearNodes: () => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        command: {
            /**
             * Define a command inline.
             */
            command: (fn: (props: Parameters<Command>[0]) => boolean) => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        createParagraphNear: {
            /**
             * Create a paragraph nearby.
             */
            createParagraphNear: () => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        deleteCurrentNode: {
            /**
             * Delete the node that currently has the selection anchor.
             */
            deleteCurrentNode: () => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        deleteNode: {
            /**
             * Delete a node.
             */
            deleteNode: (typeOrName: string | NodeType) => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        deleteRange: {
            /**
             * Delete a given range.
             */
            deleteRange: (range: Range) => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        deleteSelection: {
            /**
             * Delete the selection, if there is one.
             */
            deleteSelection: () => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        enter: {
            /**
             * Trigger enter.
             */
            enter: () => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        exitCode: {
            /**
             * Exit from a code block.
             */
            exitCode: () => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        extendMarkRange: {
            /**
             * Extends the text selection to the current mark.
             */
            extendMarkRange: (typeOrName: string | MarkType, attributes?: Record<string, any>) => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        first: {
            /**
             * Runs one command after the other and stops at the first which returns true.
             */
            first: (commands: Command[] | ((props: CommandProps) => Command[])) => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        focus: {
            /**
             * Focus the editor at the given position.
             */
            focus: (position?: FocusPosition, options?: {
                scrollIntoView?: boolean;
            }) => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        forEach: {
            /**
             * Loop through an array of items.
             */
            forEach: <T>(items: T[], fn: (item: T, props: CommandProps & {
                index: number;
            }) => boolean) => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        insertContent: {
            /**
             * Insert a node or string of HTML at the current position.
             */
            insertContent: (value: Content, options?: {
                parseOptions?: ParseOptions;
                updateSelection?: boolean;
            }) => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        insertContentAt: {
            /**
             * Insert a node or string of HTML at a specific position.
             */
            insertContentAt: (position: number | Range, value: Content, options?: {
                parseOptions?: ParseOptions;
                updateSelection?: boolean;
            }) => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        joinUp: {
            /**
             * Join two nodes Up.
             */
            joinUp: () => ReturnType;
        };
        joinDown: {
            /**
             * Join two nodes Down.
             */
            joinDown: () => ReturnType;
        };
        joinBackward: {
            /**
             * Join two nodes Backwards.
             */
            joinBackward: () => ReturnType;
        };
        joinForward: {
            /**
             * Join two nodes Forwards.
             */
            joinForward: () => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        keyboardShortcut: {
            /**
             * Trigger a keyboard shortcut.
             */
            keyboardShortcut: (name: string) => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        lift: {
            /**
             * Removes an existing wrap.
             */
            lift: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        liftEmptyBlock: {
            /**
             * Lift block if empty.
             */
            liftEmptyBlock: () => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        liftListItem: {
            /**
             * Lift the list item into a wrapping list.
             */
            liftListItem: (typeOrName: string | NodeType) => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        newlineInCode: {
            /**
             * Add a newline character in code.
             */
            newlineInCode: () => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        resetAttributes: {
            /**
             * Resets some node attributes to the default value.
             */
            resetAttributes: (typeOrName: string | NodeType | MarkType, attributes: string | string[]) => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        scrollIntoView: {
            /**
             * Scroll the selection into view.
             */
            scrollIntoView: () => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        selectAll: {
            /**
             * Select the whole document.
             */
            selectAll: () => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        selectNodeBackward: {
            /**
             * Select a node backward.
             */
            selectNodeBackward: () => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        selectNodeForward: {
            /**
             * Select a node forward.
             */
            selectNodeForward: () => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        selectParentNode: {
            /**
             * Select the parent node.
             */
            selectParentNode: () => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        selectTextblockEnd: {
            /**
             * Moves the cursor to the end of current text block.
             */
            selectTextblockEnd: () => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        selectTextblockStart: {
            /**
             * Moves the cursor to the start of current text block.
             */
            selectTextblockStart: () => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        setContent: {
            /**
             * Replace the whole document with new content.
             */
            setContent: (content: Content, emitUpdate?: boolean, parseOptions?: ParseOptions) => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        setMark: {
            /**
             * Add a mark with new attributes.
             */
            setMark: (typeOrName: string | MarkType, attributes?: Record<string, any>) => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        setMeta: {
            /**
             * Store a metadata property in the current transaction.
             */
            setMeta: (key: string, value: any) => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        setNode: {
            /**
             * Replace a given range with a node.
             */
            setNode: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        setNodeSelection: {
            /**
             * Creates a NodeSelection.
             */
            setNodeSelection: (position: number) => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        setTextSelection: {
            /**
             * Creates a TextSelection.
             */
            setTextSelection: (position: number | Range) => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        sinkListItem: {
            /**
             * Sink the list item down into an inner list.
             */
            sinkListItem: (typeOrName: string | NodeType) => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        splitBlock: {
            /**
             * Forks a new node from an existing node.
             */
            splitBlock: (options?: {
                keepMarks?: boolean;
            }) => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        splitListItem: {
            /**
             * Splits one list item into two list items.
             */
            splitListItem: (typeOrName: string | NodeType) => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        toggleList: {
            /**
             * Toggle between different list types.
             */
            toggleList: (listTypeOrName: string | NodeType, itemTypeOrName: string | NodeType) => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        toggleMark: {
            /**
             * Toggle a mark on and off.
             */
            toggleMark: (typeOrName: string | MarkType, attributes?: Record<string, any>, options?: {
                /**
                 * Removes the mark even across the current selection. Defaults to `false`.
                 */
                extendEmptyMarkRange?: boolean;
            }) => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        toggleNode: {
            /**
             * Toggle a node with another node.
             */
            toggleNode: (typeOrName: string | NodeType, toggleTypeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        toggleWrap: {
            /**
             * Wraps nodes in another node, or removes an existing wrap.
             */
            toggleWrap: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        undoInputRule: {
            /**
             * Undo an input rule.
             */
            undoInputRule: () => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        unsetAllMarks: {
            /**
             * Remove all marks in the current selection.
             */
            unsetAllMarks: () => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        unsetMark: {
            /**
             * Remove all marks in the current selection.
             */
            unsetMark: (typeOrName: string | MarkType, options?: {
                /**
                 * Removes the mark even across the current selection. Defaults to `false`.
                 */
                extendEmptyMarkRange?: boolean;
            }) => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        updateAttributes: {
            /**
             * Update attributes of a node or mark.
             */
            updateAttributes: (typeOrName: string | NodeType | MarkType, attributes: Record<string, any>) => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        wrapIn: {
            /**
             * Wraps nodes in another node.
             */
            wrapIn: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType;
        };
    }
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        wrapInList: {
            /**
             * Wrap a node in a list.
             */
            wrapInList: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType;
        };
    }
}

declare const Commands$1: Extension<any, any>;

declare const Editable: Extension<any, any>;

declare const FocusEvents: Extension<any, any>;

declare const Keymap: Extension<any, any>;

declare const Tabindex: Extension<any, any>;

declare const index_ClipboardTextSerializer: typeof ClipboardTextSerializer;
declare const index_Editable: typeof Editable;
declare const index_FocusEvents: typeof FocusEvents;
declare const index_Keymap: typeof Keymap;
declare const index_Tabindex: typeof Tabindex;
declare namespace index {
  export {
    index_ClipboardTextSerializer as ClipboardTextSerializer,
    Commands$1 as Commands,
    index_Editable as Editable,
    index_FocusEvents as FocusEvents,
    index_Keymap as Keymap,
    index_Tabindex as Tabindex,
  };
}

interface HTMLElement$1 {
    editor?: Editor;
}
declare class Editor extends EventEmitter<EditorEvents> {
    private commandManager;
    extensionManager: ExtensionManager;
    private css;
    schema: Schema;
    view: EditorView;
    isFocused: boolean;
    extensionStorage: Record<string, any>;
    options: EditorOptions;
    constructor(options?: Partial<EditorOptions>);
    /**
     * Returns the editor storage.
     */
    get storage(): Record<string, any>;
    /**
     * An object of all registered commands.
     */
    get commands(): SingleCommands;
    /**
     * Create a command chain to call multiple commands at once.
     */
    chain(): ChainedCommands;
    /**
     * Check if a command or a command chain can be executed. Without executing it.
     */
    can(): CanCommands;
    /**
     * Inject CSS styles.
     */
    private injectCSS;
    /**
     * Update editor options.
     *
     * @param options A list of options
     */
    setOptions(options?: Partial<EditorOptions>): void;
    /**
     * Update editable state of the editor.
     */
    setEditable(editable: boolean, emitUpdate?: boolean): void;
    /**
     * Returns whether the editor is editable.
     */
    get isEditable(): boolean;
    /**
     * Returns the editor state.
     */
    get state(): EditorState;
    /**
     * Register a ProseMirror plugin.
     *
     * @param plugin A ProseMirror plugin
     * @param handlePlugins Control how to merge the plugin into the existing plugins.
     */
    registerPlugin(plugin: Plugin, handlePlugins?: (newPlugin: Plugin, plugins: Plugin[]) => Plugin[]): void;
    /**
     * Unregister a ProseMirror plugin.
     *
     * @param nameOrPluginKey The plugins name
     */
    unregisterPlugin(nameOrPluginKey: string | PluginKey): void;
    /**
     * Creates an extension manager.
     */
    private createExtensionManager;
    /**
     * Creates an command manager.
     */
    private createCommandManager;
    /**
     * Creates a ProseMirror schema.
     */
    private createSchema;
    /**
     * Creates a ProseMirror view.
     */
    private createView;
    /**
     * Creates all node views.
     */
    createNodeViews(): void;
    isCapturingTransaction: boolean;
    private capturedTransaction;
    captureTransaction(fn: Function): Transaction | null;
    /**
     * The callback over which to send transactions (state updates) produced by the view.
     *
     * @param transaction An editor state transaction
     */
    private dispatchTransaction;
    /**
     * Get attributes of the currently selected node or mark.
     */
    getAttributes(nameOrType: string | NodeType | MarkType): Record<string, any>;
    /**
     * Returns if the currently selected node or mark is active.
     *
     * @param name Name of the node or mark
     * @param attributes Attributes of the node or mark
     */
    isActive(name: string, attributes?: {}): boolean;
    isActive(attributes: {}): boolean;
    /**
     * Get the document as JSON.
     */
    getJSON(): JSONContent;
    /**
     * Get the document as HTML.
     */
    getHTML(): string;
    /**
     * Get the document as text.
     */
    getText(options?: {
        blockSeparator?: string;
        textSerializers?: Record<string, TextSerializer>;
    }): string;
    /**
     * Check if there is no content.
     */
    get isEmpty(): boolean;
    /**
     * Get the number of characters for the current document.
     *
     * @deprecated
     */
    getCharacterCount(): number;
    /**
     * Destroy the editor.
     */
    destroy(): void;
    /**
     * Check if the editor is already destroyed.
     */
    get isDestroyed(): boolean;
}

declare class CommandManager {
    editor: Editor;
    rawCommands: AnyCommands;
    customState?: EditorState;
    constructor(props: {
        editor: Editor;
        state?: EditorState;
    });
    get hasCustomState(): boolean;
    get state(): EditorState;
    get commands(): SingleCommands;
    get chain(): () => ChainedCommands;
    get can(): () => CanCommands;
    createChain(startTr?: Transaction, shouldDispatch?: boolean): ChainedCommands;
    createCan(startTr?: Transaction): CanCommands;
    buildProps(tr: Transaction, shouldDispatch?: boolean): CommandProps;
}

/**
 * Returns a new `Transform` based on all steps of the passed transactions.
 */
declare function combineTransactionSteps(oldDoc: Node$1, transactions: Transaction[]): Transform;

declare function defaultBlockAt(match: ContentMatch): NodeType | null;

declare function findChildren(node: Node$1, predicate: Predicate): NodeWithPos[];

/**
 * Same as `findChildren` but searches only within a `range`.
 */
declare function findChildrenInRange(node: Node$1, range: Range, predicate: Predicate): NodeWithPos[];

declare function findParentNode(predicate: Predicate): (selection: Selection) => {
    pos: number;
    start: number;
    depth: number;
    node: prosemirror_model.Node;
} | undefined;

declare function findParentNodeClosestToPos($pos: ResolvedPos, predicate: Predicate): {
    pos: number;
    start: number;
    depth: number;
    node: Node$1;
} | undefined;

declare function generateHTML(doc: JSONContent, extensions: Extensions): string;

declare function generateJSON(html: string, extensions: Extensions): Record<string, any>;

declare function generateText(doc: JSONContent, extensions: Extensions, options?: {
    blockSeparator?: string;
    textSerializers?: Record<string, TextSerializer>;
}): string;

declare function getAttributes(state: EditorState, typeOrName: string | NodeType | MarkType): Record<string, any>;

declare type ChangedRange = {
    oldRange: Range;
    newRange: Range;
};
/**
 * Returns a list of changed ranges
 * based on the first and last state of all steps.
 */
declare function getChangedRanges(transform: Transform): ChangedRange[];

interface DebugJSONContent extends JSONContent {
    from: number;
    to: number;
}
declare function getDebugJSON(node: Node$1, startOffset?: number): DebugJSONContent;

declare function getExtensionField<T = any>(extension: AnyExtension, field: string, context?: Omit<MaybeThisParameterType<T>, 'parent'>): RemoveThis<T>;

declare function getHTMLFromFragment(fragment: Fragment, schema: Schema): string;

declare function getMarkAttributes(state: EditorState, typeOrName: string | MarkType): Record<string, any>;

declare function getMarkRange($pos: ResolvedPos, type: MarkType, attributes?: Record<string, any>): Range | void;

declare function getMarksBetween(from: number, to: number, doc: Node$1): MarkRange[];

declare function getMarkType(nameOrType: string | MarkType, schema: Schema): MarkType;

declare function getNodeAttributes(state: EditorState, typeOrName: string | NodeType): Record<string, any>;

declare function getNodeType(nameOrType: string | NodeType, schema: Schema): NodeType;

declare function getSchema(extensions: Extensions): Schema;

declare function getText(node: Node$1, options?: {
    blockSeparator?: string;
    textSerializers?: Record<string, TextSerializer>;
}): string;

declare function getTextBetween(startNode: Node$1, range: Range, options?: {
    blockSeparator?: string;
    textSerializers?: Record<string, TextSerializer>;
}): string;

declare const getTextContentFromNodes: ($from: ResolvedPos, maxMatch?: number) => string;

declare function getTextSerializersFromSchema(schema: Schema): Record<string, TextSerializer>;

declare function isActive(state: EditorState, name: string | null, attributes?: Record<string, any>): boolean;

declare function isList(name: string, extensions: Extensions): boolean;

declare function isMarkActive(state: EditorState, typeOrName: MarkType | string | null, attributes?: Record<string, any>): boolean;

declare function isNodeActive(state: EditorState, typeOrName: NodeType | string | null, attributes?: Record<string, any>): boolean;

declare function isNodeEmpty(node: Node$1): boolean;

declare function isNodeSelection(value: unknown): value is NodeSelection;

declare function isTextSelection(value: unknown): value is TextSelection;

declare function posToDOMRect(view: EditorView, from: number, to: number): DOMRect;

/**
 * Build an input rule that adds a mark when the
 * matched text is typed into it.
 */
declare function markInputRule(config: {
    find: InputRuleFinder;
    type: MarkType;
    getAttributes?: Record<string, any> | ((match: ExtendedRegExpMatchArray) => Record<string, any>) | false | null;
}): InputRule;

/**
 * Build an input rule that adds a node when the
 * matched text is typed into it.
 */
declare function nodeInputRule(config: {
    find: InputRuleFinder;
    type: NodeType;
    getAttributes?: Record<string, any> | ((match: ExtendedRegExpMatchArray) => Record<string, any>) | false | null;
}): InputRule;

/**
 * Build an input rule that changes the type of a textblock when the
 * matched text is typed into it. When using a regular expresion you’ll
 * probably want the regexp to start with `^`, so that the pattern can
 * only occur at the start of a textblock.
 */
declare function textblockTypeInputRule(config: {
    find: InputRuleFinder;
    type: NodeType;
    getAttributes?: Record<string, any> | ((match: ExtendedRegExpMatchArray) => Record<string, any>) | false | null;
}): InputRule;

/**
 * Build an input rule that replaces text when the
 * matched text is typed into it.
 */
declare function textInputRule(config: {
    find: InputRuleFinder;
    replace: string;
}): InputRule;

/**
 * Build an input rule for automatically wrapping a textblock when a
 * given string is typed. When using a regular expresion you’ll
 * probably want the regexp to start with `^`, so that the pattern can
 * only occur at the start of a textblock.
 *
 * `type` is the type of node to wrap in.
 *
 * By default, if there’s a node with the same type above the newly
 * wrapped node, the rule will try to join those
 * two nodes. You can pass a join predicate, which takes a regular
 * expression match and the node before the wrapped node, and can
 * return a boolean to indicate whether a join should happen.
 */
declare function wrappingInputRule(config: {
    find: InputRuleFinder;
    type: NodeType;
    getAttributes?: Record<string, any> | ((match: ExtendedRegExpMatchArray) => Record<string, any>) | false | null;
    joinPredicate?: (match: ExtendedRegExpMatchArray, node: Node$1) => boolean;
}): InputRule;

declare class NodeView<Component, NodeEditor extends Editor = Editor, Options extends NodeViewRendererOptions = NodeViewRendererOptions> implements NodeView$1 {
    component: Component;
    editor: NodeEditor;
    options: Options;
    extension: Node;
    node: Node$1;
    decorations: Decoration[];
    getPos: any;
    isDragging: boolean;
    constructor(component: Component, props: NodeViewRendererProps, options?: Partial<Options>);
    mount(): void;
    get dom(): HTMLElement;
    get contentDOM(): HTMLElement | null;
    onDragStart(event: DragEvent): void;
    stopEvent(event: Event): boolean;
    ignoreMutation(mutation: MutationRecord | {
        type: 'selection';
        target: Element;
    }): boolean;
    updateAttributes(attributes: {}): void;
    deleteNode(): void;
}

/**
 * Build an paste rule that adds a mark when the
 * matched text is pasted into it.
 */
declare function markPasteRule(config: {
    find: PasteRuleFinder;
    type: MarkType;
    getAttributes?: Record<string, any> | ((match: ExtendedRegExpMatchArray) => Record<string, any>) | false | null;
}): PasteRule;

/**
 * Build an paste rule that adds a node when the
 * matched text is pasted into it.
 */
declare function nodePasteRule(config: {
    find: RegExp;
    type: NodeType;
    getAttributes?: Record<string, any> | ((match: ExtendedRegExpMatchArray) => Record<string, any>) | false | null;
}): PasteRule;

/**
 * Build an paste rule that replaces text when the
 * matched text is pasted into it.
 */
declare function textPasteRule(config: {
    find: PasteRuleFinder;
    replace: string;
}): PasteRule;

interface TrackerResult {
    position: number;
    deleted: boolean;
}
declare class Tracker {
    transaction: Transaction;
    currentStep: number;
    constructor(transaction: Transaction);
    map(position: number): TrackerResult;
}

/**
 * Optionally calls `value` as a function.
 * Otherwise it is returned directly.
 * @param value Function or any value.
 * @param context Optional context to bind to function.
 * @param props Optional props to pass to function.
 */
declare function callOrReturn<T>(value: T, context?: any, ...props: any[]): MaybeReturnType<T>;

declare function createStyleTag(style: string, nonce?: string): HTMLStyleElement;

/**
 * Remove a property or an array of properties from an object
 * @param obj Object
 * @param key Key to remove
 */
declare function deleteProps(obj: Record<string, any>, propOrProps: string | string[]): Record<string, any>;

declare function elementFromString(value: string): HTMLElement;

declare function escapeForRegEx(string: string): string;

declare function findDuplicates(items: any[]): any[];

declare function fromString(value: any): any;

declare function isEmptyObject(value?: {}): boolean;

declare function isFunction(value: any): value is Function;

declare function isiOS(): boolean;

declare function isMacOS(): boolean;

declare function isNumber(value: any): value is number;

declare function isPlainObject(value: any): value is Record<string, any>;

declare function isRegExp(value: any): value is RegExp;

declare function isString(value: any): value is string;

declare function mergeAttributes(...objects: Record<string, any>[]): Record<string, any>;

declare function mergeDeep(target: Record<string, any>, source: Record<string, any>): Record<string, any>;

declare function minMax(value?: number, min?: number, max?: number): number;

/**
 * Check if object1 includes object2
 * @param object1 Object
 * @param object2 Object
 */
declare function objectIncludes(object1: Record<string, any>, object2: Record<string, any>, options?: {
    strict: boolean;
}): boolean;

/**
 * Removes duplicated values within an array.
 * Supports numbers, strings and objects.
 */
declare function removeDuplicates<T>(array: T[], by?: {
    (value: any, replacer?: ((this: any, key: string, value: any) => any) | undefined, space?: string | number | undefined): string;
    (value: any, replacer?: (string | number)[] | null | undefined, space?: string | number | undefined): string;
}): T[];

interface Commands<ReturnType = any> {
}
interface ExtensionConfig<Options = any, Storage = any> {
}
interface NodeConfig<Options = any, Storage = any> {
}
interface MarkConfig<Options = any, Storage = any> {
}

export { AnyCommands, AnyConfig, AnyExtension, Attribute, Attributes, CanCommands, ChainedCommands, ChangedRange, Command, CommandManager, CommandProps, CommandSpec, Commands, Content, Diff, Dispatch, Editor, EditorEvents, EditorOptions, EnableRules, ExtendedRegExpMatchArray, Extension, ExtensionAttribute, ExtensionConfig, Extensions, FocusPosition, GlobalAttributes, HTMLContent, HTMLElement$1 as HTMLElement, InputRule, InputRuleFinder, InputRuleMatch, JSONContent, KeyboardShortcutCommand, KeysWithTypeOf, Mark, MarkConfig, MarkRange, MaybeReturnType, MaybeThisParameterType, Node, NodeConfig, NodeRange, NodeView, NodeViewProps, NodeViewRenderer, NodeViewRendererOptions, NodeViewRendererProps, NodeWithPos, Overwrite, ParentConfig, PasteRule, PasteRuleFinder, PasteRuleMatch, PickValue, Predicate, Primitive, Range, RawCommands, RemoveThis, SingleCommands, TextSerializer, Tracker, TrackerResult, UnionCommands, UnionToIntersection, ValuesOf, callOrReturn, combineTransactionSteps, createStyleTag, defaultBlockAt, deleteProps, elementFromString, escapeForRegEx, index as extensions, findChildren, findChildrenInRange, findDuplicates, findParentNode, findParentNodeClosestToPos, fromString, generateHTML, generateJSON, generateText, getAttributes, getChangedRanges, getDebugJSON, getExtensionField, getHTMLFromFragment, getMarkAttributes, getMarkRange, getMarkType, getMarksBetween, getNodeAttributes, getNodeType, getSchema, getText, getTextBetween, getTextContentFromNodes, getTextSerializersFromSchema, inputRulesPlugin, isActive, isEmptyObject, isFunction, isList, isMacOS, isMarkActive, isNodeActive, isNodeEmpty, isNodeSelection, isNumber, isPlainObject, isRegExp, isString, isTextSelection, isiOS, markInputRule, markPasteRule, mergeAttributes, mergeDeep, minMax, nodeInputRule, nodePasteRule, objectIncludes, pasteRulesPlugin, posToDOMRect, removeDuplicates, textInputRule, textPasteRule, textblockTypeInputRule, wrappingInputRule };
